
## std::crypto::fri::frif2e2
| Procedure | Description |
| ----------- | ------------- |
| mul_base | Given a stack with initial configuration given by [x,a1,a0,...] where a = (a0,a1) is an element<br /><br />in the field extension and x is an element of the base field, this procedure computes the multiplication<br /><br />of x, when looked at as (x,0), with a in the extension field. The output is [xa1,xa0,...] |
| fold_2 | Given a stack in the following initial configuration [a1, a0, b1, b0, c1, c0, d1, d0, ...] the following<br /><br />procedure computes (a + b + ((a - b) * c * d^(-1)))/2 with the assumption that d1 is equal to 0<br /><br />Cost: 15 + 1 Esub + 2 mulBase + 1 Emul + 2 Eadd<br /><br />Cost: ~70 cycles in Ext2 |
| next_pos_exp | This procedure computes the folded position in the exponent of the corresponding domain generator<br /><br />normalized by the offset. It uses an algebraic relationship between the original and folded positions<br /><br />given by multiplication with the 2nd primitive root of unity in our field.<br /><br />Cost: 10 cycles<br /><br />Input:    #[?, poe, poe, ...]<br /><br />Output:   #[poe_sq, xs, ...] |
| preprocess | Preprocess the layer commitments C as well as num_q (number of queries), d_size (initial domain size),<br /><br />g (intial domain generator), t_depth (initial tree depth) and (a0, a1) (the folding challenges alpha).<br /><br />The address of the word (num_q, d_size, g, t_depth) will be at locaddr.0. The commitments and alphas will be<br /><br />at the subsequent addresses. The total number of such commitments and alphas is t_depth - 3<br /><br />(excluding the remainder commitment). |
| prepare_next | Helper procedure used to prepare the stack for the next iteration of verify_query_layer for a<br /><br />positon p. (ptr' - 2) is the address of the commitment for the next layer and (ptr' - 1) is<br /><br />the address of the next alpha folding challenge.<br /><br />Cost: ~30 cycles<br /><br />Input: [t_depth, e1, e0, p, d_size, poe, ptr', ..]<br /><br />Output: [d, p, C, t_depth, e1, e0, poe, a1, a0, ptr'-2, ..] |
| verify_query_layer | The following procedure computes an iteration of FRI verification for a query.<br /><br />The stack starts in the following initial configuration [d_size, p, C, t_depth, e1, e0, poe, a1, a0, ptr', f_ptr..]<br /><br />where d_size is the current domain size, p the current position, C is the commitment of current layer, t_depth<br /><br />its corresponding tree depth, (e1, e0) is the evaluation point, poe is the position in the exponent<br /><br />of the domain generator, (a1, a0) is the alpha to compute the next evaluation point. The pointers ptr' and f_ptr point<br /><br />to the current layer commitment (and its corresponding challenge) while f_ptr is used to keep track of the first such<br /><br />commitment for subsequent queries.<br /><br />TODO: Check where/if some checks are needed at the beginning, like p < d_size (p&d_size are u32) and that 2^t_depth == d_size<br /><br />Cost: ~200 cycles<br /><br />Input:  [d_size, p, C, t_depth, e1, e0, poe, a1, a0, ptr', f_ptr..]<br /><br />Output: [t_depth-1, e1, e0, p%d_size/2, d_size/2, poe_sq, ptr', f_ptr..] |
| verify_query | Verify a single query. The expected stack configuration is [d_size, p, C, t_depth, e1, e0, poe, a1, a0, f_ptr-2, f_ptr, i_ptr, ...]<br /><br />where i_ptr is the address storing the current (num_q, d_size, g, t_depth), num_q is the index of the current query,<br /><br />d_size is the domain size of the LDE, g is its generator and ptr' is the address of the commitment to<br /><br />the first layer with the commitments to subsequent layers laid out, in alternating order with the layer<br /><br />alphas, in the subsequent addresses i.e. f_ptr - 2, f_ptr - 1 ...<br /><br />Input:  #[d_size, p, C, t_depth, e1, e0, poe, a1, a0, f_ptr - 2, f_ptr, i_ptr, ...]<br /><br />Output: #[p%d_size/2, d_size/2, poe_sq, i_ptr + 1, f_ptr, i_ptr, rem1, rem0...] |
| verify_remainder_com | Verify that the hash of the remainder codeword is equal to the commitment provided by the prover<br /><br />The following implementation relies on the assumption that the blowup factor is 8 and that the degree<br /><br />of the remainder is zero.<br /><br />Cost: ~80 cycles<br /><br />Input: #[p%d_size/2, d_size/2, poe_sq, i_ptr + 1, f_ptr, i_ptr, rem1, rem0...]<br /><br />Output: () |
| verify_fri | This procedure verifies a FRI proof with number of queries num_q, initial domain size d_size, generator<br /><br />for this domain g, and tree depth of the initial layer Merkle tree commitment. i_ptr points to<br /><br />the address containing values common to all queries as well as to keep track of the queries<br /><br />that remain to be verified. f_ptr points to the address that will contain the result of adv_pipe.<br /><br />f_ptr - 2 * i - 2 points to the layer folding challenges alpha and f_ptr - 2 * i - 1 points to<br /><br />the i-th layer commitment.<br /><br />Input: #[i_ptr, num_q, d_size, g, t_depth, f_ptr, ...]<br /><br />Output: () |
